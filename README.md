# Домашнее задание №4

**Дедлайны**: 11.06.2019 12:10

## Задачи
#### 1. Нестареющая классика (2 балла)
Реализуйте класс «n-мерный» вектор. У этого класса должны быть определены все 
естественные для вектора операции:
 - сложение
 - вычитание
 - скалярное произведение 
 - сравнение на равенство
 - умножение на константу 
 
При этом должны быть реализованы "отраженные" операции, а также операции присваивания: 
```python
vec1 = Vector([1, 2, 3])
vec2 = Vector([1, 2, 3])

vec1 += vec2 
vec3 = 3 * vec1
``` 
 
а также операции:
 - вычисление длины
 - получение/изменение элемента по индексу 
 - получение строкового представления

#### 2. Logger (3 балла)

Напишите класс, которой ведет журнал, какие методы у него вызывались. То есть у объектов данного класса должна быть
возможность вызвать любой метод с любыми аргументами, а потом можно вызвать специальный метод (удобно здесь использовать
`__str__`), который выдаст строку-лог со всей информацией о вызовах и аргументах. Кроме того, должна быть возможность
унаследоваться от данного класса, чтобы добавить логирование к любому классу. При этом функции, определенные в
классе-наследнике, все равно должны выполняться.

Для простоты игнорируйте атрибуты методов (докстринги и т.п.).

#### 3. Implicit Int (1 балл)
Напишите декоратор `implicit_int`. Если приписать его к классу, то при обращении к необъявленному полю экземпляра этого
класса будет возвращаться значение 0.

```python
@implicit_int
class A:
    pass
    
a = A()
print(a.e + 589)  # Вывод: 589
```

#### 4. Timer (1 балл)

Напишите менеджер контекста, который позволит засекать время выполнения блока кода с помощью конструкции
`with` и выводить это время на экран по выходу из блока.

Пример использования:
```python
with Timer():
    do_some_long_stuff()
```


#### 5. Менеджер-декоратор (1,5 балла)
Реализовать декоратор `context_decorator`, позволяющий использовать экземпляр класса, который является мендежером
 контекста, в качестве декоратора.

```python
@context_decorator
class PrinterContext:
    def __enter__(self):
        print("Enter")

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Exit")
        return True


@PrinterContext()
def foo():
    print("Inside of function") 
```

При этом подразумевается, что 
```python
@PrinterCotext()
def foo():
    print("Inside of function")
   
foo()
```

тоже самое, что и 
```python
def foo():
    print("Inside of function")

with PrinterCotext():
    foo()
```
т.е. в обоих случаях должно быть выведено следующее:
```python
'Enter'
'Inside of function'
'Exit'
```

**Продекорированная функция (в данном случае `foo`) все еще должна возвращать значение.**

#### 6. Transaction (3 балла)

Вам необходимо написать менеджер контекстов, который позволит безопасно работать с транзакциями. 

Напишите класс `Storage`, в котором будут храниться какие-то данные ввиде словаря. Эти данные должны быть закрытыми и 
их можно читать только через операцию `[]`. У этого класса должен быть метод `edit`, который возвращает менеджер контекста, позволяющий редактировать
исходный объект (опять же через `[]`). При этом результаты редактирования записываются в исходный объект только если 
весь блок выполнился успешно.

Пример использования:
```python
s = Storage()
with s.edit() as se:
    se['a'] = 1
    may_be_an_exception_here()
```

   
        
