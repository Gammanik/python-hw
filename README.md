# Домашнее задание №3

**Дедлайны**: 10.23.2019 12:10

## Задачи

#### 1. Типизация (2 балла)
Реализовать декоратор `@typing`, проверяющий соответствие типов переданных аргументов типовым аннотациям в сигнатуре функции.

Для простоты:
- можно не учитывать параметризованные типовые аннотации и бросать исключение с сообщением о том,
что они не поддерживаются

Например, в таком случае
```python
@typing
def func_with_type_annotation(arg: List[int]):
    ...
```

Но можно получить до 2 дополнительных баллов, реализовав их поддержку.

- если у аргумента не указана типовая аннотация, можно считать, что тип аргумента `Any`.
- если аргумент аннотирован типом, созданным с помощью NewType, можно считать, что аргумент аннотирован типом,
от которого NewType был создан

Например, в таком случае
```python
NT = NewType('NT', int)

@typing
def func_with_type_annotation(arg: NT):
    ...
```
можно считать, что `func_with_type_annotation` ожидает получить аргумент `arg` типа `int` или его наследников.

#### 2. Not lru cached (2 балла)
Реализуйте декоратор `cached`. Функция, к которой был применен этот декоратор, будет кэшировать результаты своей работы
на определенных аргументах. В этом задании необходимо учитывать дефолтные значения
ключевых аргументов. Например:
```python
@cached
def foo(a=42):
    ...

foo(42)
foo()  # использует закешированное значение
```

Помимо этого, у декоратора `cached` есть ключевой аргумент `cache_size`, имеющий значение `None` по-умолчанию.
Если `cache_size` не установлен, то продекорированная функция запоминает все посчитанные значения.
Если значение `cache_size` -- натуральное число, то функция будет помнить только последние `cache_size` посчитанных
значений (при `cache_size = 0` значения не кешируются).

```python
@cached(cache_size=1)
def foo(a):
    ...

foo(1)  # считает значение
foo(1)  # использует закешированное значение
foo(2)
foo(1)  # считает значение
```

#### 3. N times (1 балл)
Реализуйте декоратор n_times. Результатом его работы должна быть функцию, вызывающая декорируемую функцию n раз. 
Возвращаемое значение декорируемой функции можно игнорировать.

```python
@n_times(3)
def do_something():
    print("Something is going on!")

>>> do_something()
Something is going on!
Something is going on!
Something is going on!
```

#### 4. trace_if (1.5 балла)
Напишите декоратор trace, который будет выводить информацию о вызове функции, только если переданные аргументы 
удовлетворяют предикату.
```python
>>> @trace_if(lambda x, y, **kwargs: kwargs.get("integral"))
... def div(x, y, integral=False):
... return x // y if integral else x / y
...
>>> div(4, 2)
2
>>> div(4, 2, integral=True)
div (4, 2) {'integral': True}
2
```
#### 5. Победи зависимость. (2 балла)
В данном задании вам предстоит написать декораторы `@register` и `@depends_on`, позволяющие указывать зависимости
между функциями:
```python
@register
def do_something():
    print("doing something")

@depends_on(["do_something"])
def do_other_thing():
    print("doing other thing")
```

Функции должны выполняться, как обычные, но перед их выполнением должны быть выполнены их зависимости
в порядке обхода dfs.

Для функций без зависимостей логика выполнения должна остаться без изменений.

```python
>>> do_other_thing()
doing something
doing other thing
```
В случае, если при выполнении встретилась циклическая зависимость, необходимо бросить исключение.
