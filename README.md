# Переписка контрольной работы


В контрольной работе 4 задачи, за каждую задачу можно набрать максимум 1 балл.
Для сдачи контрольной работы необходимо по каждой задаче набрать +0.7 баллов.

Если суммарно за работу вы наберете 2 или более баллов, то на следующей
переписке вам автоматически зачтутся все задачи, за которые вы на этой
итерации набрали +0.7 баллов.

## Задачи

#### 1. `SuperStorer`

Создайте метакласс `SuperSerializer`. Метакласс имеет два метода:
- `store(filename)` — сохраняет в файл `filename` сведения обо всех существующих экземплярах классов, 
у которых `SuperSerializer` является метаклассом. Можно считать, что все поля во всех экземплярах являются
целыми числами.
- `load(filename)` — создаёт в глобальной области видимости набор экземпляров, сведения о которых были 
ранее сохранены в `filename` функцией `store`.
 
При этом при загрузке экземпляры должны **восстановить имена**, которые у них были до сохранения.

    class A(metaclass = SuperStorer):
        pass
    
    a = A()
    a.x = 5
    SuperStorer.store('text.txt')
    
    ##################################
    
    SuperStorer.load('text.txt')
    print(a.x)

#### 2. `MultiSet`

Создайте класс `MultiSet` - мультимножество (множество позволяющее хранить несколько равных экземпляров, аналог Counter).

Необходимо поддержать следующие методы:
- `set | other` - возвращает **новое** множество, являющееся объединением двух заданных.
- `set & other` - возвращает **новое** множество, являющееся пересечением двух заданных.
- `set <= other` - возвращает True, если set является подмножеством other
- `set >= other` - аналогично
- `set - element` - возвращает **новое** множество, полученное из set удалением одного экземпляра element, если element
                    встречался, или же кидает исключение `KeyError`, если элемент не встречался
- `set - other` - возвращает **новое** множество, полученное из set удалением элементов, встречающихся в other
- `set + element` - аналогично
- `iter(set)` - итератор по мультимножеству, в котором равные элементы идут подряд
- `element in set` - очевидно
- `set -= element` - изменяет множество
- `set -= other`
- `set += element`
- `set |= other` - объединяет множества, изменяет  set

```python
s = Multiset()
s += 1
s += 1
s += 2
s += 1
print(list(s)) # [1, 1, 1, 2]
s -= 1
print(list(s)) # [1, 1, 2]

b = Multiset()
b += 1
b += 2
print(b <= s) # True
print(s <= b) # False

print(list(s - b)) # [1]
```

**Примечание:** данное задание на реализацию структуры данных, поэтому
в данном задании **запрещается пользоваться любыми модулями, а также
set и dict**.

#### 3. `@spy`

Напишите декоратор `@spy` и функцию `bond()`, которая является
генератором и выдает кортежи из двух элементов – суммарного времени
работы продекоррированной с помощью `@spy` функции и ее имени.
Результаты должны быть отсортированы в порядке убывания времени работы.

#### 4. `apply`

Напишите декораторы `@apply(func, predicate)`, где `predicate` –
функция, которая возвращает True или False, и `@register`.

```python
@apply(func, pred)
def bar(num):
	pass

@register
def func(num):
    pass
```

Если вызывается функция `func`, "зарегистрированная" с помощью
`register`, от какого-то набора параметров, то нужно найти первую
продекорированную `apply` функцию, у которой в качестве первого
параметра `apply` указан `func` и для которой соответствующий
`predicate` для данного набора параметров вернет `true`.

Если не найдется такая продекорированная `apply` функция, то необходимо
вызвать исходную.

```python
def pred1(num):
	return (num > 0) and (num % 2 == 1)

def pred2(num):
	return num >= 3

@register
def foo(num):
	print("Original")

@apply(foo, pred2)
def bbb(num):
	print("Magic")

@apply(foo, pred1)
def asd(num):
	print("Modified")

foo(-1)
# Здесь пробегаемся по всем функциям, которые продекорированы @apply(foo, ...)
# bbb не подходит так как pred2 вернет false для -1
# asd - pred1 тоже выдает false
# поэтому вызывается исходная функция и выводит “Original”

foo(1)
# pred2 вернет false
# pred1 - true. Поэтому вызывается asd и выводит “Modified”

foo(2)
# все вернут false - вызывается оригинальная

foo(3)
# и pred1, и pred2 вернут true, но первая - pred2, поэтому увидим “Magic”
```

*Примечание*: подразумевается, что функции `func` и `predicate` можно
вызывать с теми же аргументами, с которыми вызывается функция, к которой
приписан `apply`.
