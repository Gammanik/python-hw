# Переписка контрольной работы №2

В контрольной работе 4 задачи, за каждую задачу можно набрать максимум 1 балл.
Для сдачи контрольной работы необходимо по каждой задаче набрать +0.7 баллов.

## Задачи
#### 1. `StructMeta`

Дан абстрактный класс `Field`:

    class Field(metaclass=abc.ABCMeta):
        @abc.abstractmethod
        def __call__(self, value):
            return value

Реализуйте метакласс `StructMeta`, который можно использовать так:

    class Student(metaclass=StructMeta):
        name = StringField()
        age = IntField()

Если у класса уже есть конструктор, метакласс ничего не делает, а
если конструктора, то добавляет новый, который записывает переданные
позиционные аргументы в соответствующие поля. Например, здесь
конструктор должен принимать строковый аргумент `name` и числовой
аргумент `age`. Обратите внимание, что порядок позиционных аргументов
соответствует порядку объявления полей в классе.

Таким образом, должна быть возможность писать так:

    >>> s = Student('Aleks', '23')
    >>> s.name, type(s.name)
    ('Aleks', str)
    >>> s.age, type(s.age)
    (23, int)

Поддерживать надо только два типа полей:
* `StringField` -- текстовое (`str`)
* `IntField` -- целочисленное (`int`)

    class StringField(Field):
        def __call__(self, value):
            return str(value)
    
    class IntField(Field):
        def __call__(self, value):
            return int(value)

В случае, если число аргументов, переданное в конструктор по умолчанию
не совпадает с количеством полей типа `Field`, объявленных в классе, то
должно быть брошено исключение. Формат сообщения об ошибке должен быть
как можно ближе к стандартному (да, к этому можем придраться).

    >>> Student('Aleks')
    TypeError: __init__() missing 1 required positional argument: 'age'
    >>> Student('Aleks', 23, None)
    TypeError: __init__() takes 3 positional arguments but 4 were given


#### 2. `HashTable`

Данное задание - задание на реализацию структуры данных.
Из готовых структур разрешается использовать только `list` и `tuple`!

Напишите класс хеш-таблицы `HashTable` с разрешением коллизий методом цепочек. 
Имеется в виду написать именно хеш-таблицу, а не класс реализующий интерфейс хеш-таблицы, а внутри хранящий все,
например, в `dict`. В качестве хеш-функции используйте функцию `hash()`.

Хеш-таблица должна поддерживать добавление, получение и удаление элементов по ключу.

    >>> htable = HashTable()
    >>> htable['qwe'] = 42
    >>> htable['qwe']
    42
    >>> del htable['qwe']
    >>> htable['qwe']
    KeyError: 'qwe'

Помимо этого необходимо реализовать возможность итерироваться по ключам (метод `keys()`) и по парам ключ-значение
(метод `items()`) таблицы. Методы `keys` и `items` должны возвращать генераторы.

    for key in htable.keys():
        print(key)
    
    for key, value in htable.items():
        print(key, value)

В дополнение к этому, итерирование по самой таблице дожно быть аналогично итерированию по keys().

    for key in htable:  #  ≡  for key in htable.keys():
        print(key)

Также необходимо реализовать метод `__contains__` для верной работы оператора 
key in hash_table.

    >>> htable = HashTable()
    >>> 'a' in htable
    False
    >>> htable['a'] = 1
    >>> 'a' in htable
    True
    >>> htable['a']
    1
    >>> del htable['a']
    >>> 'a' in htable
    False

Функция `len`, примененная к таблице, должна за константное время возвращать количество элементов в таблице.

    for key, value in enumerate('abcde'):
        htable[key] = value
    
    assert len(htable) == 5  #  5
    
#### 3. `@spy 2.0`

Напишите декоратор `@spy` и функцию `bond(func)`, которая является генератором и выдает кортежи из двух элементов –-
времени запуска (во сколько запускали) функции `func` и параметров, с которыми она была запущена.
Для работы функции `bond` необходимо, чтобы функция была продекорирована, если это не так, то должно быть сгенерировано
исключение `ValueError`.

Примечание: Необходимо учитывать дефолтные значения аргументов.

Пример использования:

    @spy
    def foo(num):
        print(num)
    
    foo(30)
    foo('hello')
    foo(5)
    for (time, parameters) in bond(foo):
        print(time)
        print(parameters)

#### 4. `Poly`

Создайте декораторы `@poly` и `@poly_default` позволяющий реализовать "полиморфизм".

    @poly(Point, Point)
    def foo(a, b):
        pass
        
    @poly(A, A)
    def foo(a, b):
        pass
    
    @poly(A)
    def foo(x):
        pass
    
    @poly_default
    def foo(a, b, c):
        pass

При вызове foo:
- от двух экземпляров `Point` должен вызываться первый метод
- от двух экземпляров `A` должен вызываться второй метод
- от одного экземпляра `А` -- третий
- во всех остальных случаях -- четвертый. 

**Примечание**: 
- функции, продекорированной `@poly_default`, может не быть. В таком случае при неизвестном наборе
параметров должно быть сгенерировано исключение. Также при выборе метода, который должен вызываться, необходимо выбрать
первый, к типам которого можно привести параметры.
- аргументы по умолчанию можно не учитывать
